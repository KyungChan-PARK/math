<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOLA Math Learning Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            max-width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .status {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
        }

        .status-item {
            padding: 0.25rem 0.75rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem 2rem;
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.85rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
        }

        button {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        button.active {
            background: #3498db;
            border-color: #3498db;
        }

        select {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        select option {
            background: #333;
        }

        .workspace {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            padding: 1rem;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: crosshair;
        }

        .info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            min-width: 200px;
        }

        .info-panel h3 {
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }

        .info-panel p {
            margin: 0.25rem 0;
            opacity: 0.9;
        }

        .gesture-feedback {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Touch feedback */
        .touch-point {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid #3498db;
            border-radius: 50%;
            background: rgba(52, 152, 219, 0.3);
            pointer-events: none;
            animation: ripple 0.6s ease-out;
        }

        @keyframes ripple {
            0% {
                width: 40px;
                height: 40px;
                opacity: 1;
            }
            100% {
                width: 80px;
                height: 80px;
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container" id="app">
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <h2 style="margin-top: 2rem;">LOLA Math Platform Loading...</h2>
            <p style="margin-top: 0.5rem; opacity: 0.7;">Initializing physics engine...</p>
        </div>
    </div>

    <script>
        // LOLA Math Platform Client
        class LOLAMathPlatform {
            constructor() {
                this.mode = 'geometry';
                this.level = 'intermediate';
                this.touchMode = 'draw';
                this.lolaServerUrl = 'http://localhost:8090';
                this.gestureServerUrl = 'http://localhost:8081';
                this.touches = [];
                this.shapes = [];
                this.selectedShape = null;
                this.init();
            }

            async init() {
                // Check LOLA server status
                try {
                    const response = await fetch(this.lolaServerUrl);
                    const status = await response.json();
                    console.log('LOLA Server Status:', status);
                } catch (error) {
                    console.warn('LOLA Server not responding, using local simulation');
                }

                // Initialize UI
                this.setupUI();
                this.setupCanvas();
                this.setupTouchHandlers();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }

            setupUI() {
                const app = document.getElementById('app');
                app.innerHTML = `
                    <header>
                        <h1>ðŸš€ LOLA Math Learning Platform</h1>
                        <div class="status">
                            <div class="status-item">Mode: <span id="current-mode">Geometry</span></div>
                            <div class="status-item">Level: <span id="current-level">Intermediate</span></div>
                            <div class="status-item">FPS: <span id="fps">60</span></div>
                        </div>
                    </header>

                    <div class="control-panel">
                        <div class="control-group">
                            <label>Math Mode</label>
                            <select id="mode-select">
                                <option value="geometry">Geometry</option>
                                <option value="algebra">Algebra</option>
                                <option value="statistics">Statistics</option>
                                <option value="calculus">Calculus</option>
                                <option value="trigonometry">Trigonometry</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label>Student Level</label>
                            <div class="button-group">
                                <button data-level="beginner">Beginner</button>
                                <button data-level="intermediate" class="active">Intermediate</button>
                                <button data-level="advanced">Advanced</button>
                                <button data-level="expert">Expert</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Touch Mode</label>
                            <div class="button-group">
                                <button data-touch="draw" class="active">Draw</button>
                                <button data-touch="select">Select</button>
                                <button data-touch="transform">Transform</button>
                                <button data-touch="erase">Erase</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Actions</label>
                            <div class="button-group">
                                <button id="clear-btn">Clear</button>
                                <button id="simulate-btn">Simulate</button>
                                <button id="save-btn">Save</button>
                            </div>
                        </div>
                    </div>

                    <div class="workspace">
                        <div class="canvas-container">
                            <canvas id="main-canvas"></canvas>
                            <div class="info-panel">
                                <h3>Touch Canvas</h3>
                                <p>Mode: <span id="info-mode">Draw</span></p>
                                <p>Objects: <span id="object-count">0</span></p>
                                <p>Touch Points: <span id="touch-count">0</span></p>
                            </div>
                        </div>

                        <div class="canvas-container">
                            <canvas id="physics-canvas"></canvas>
                            <div class="info-panel">
                                <h3>LOLA Physics</h3>
                                <p>Compression: <span id="compression">256x</span></p>
                                <p>Simulation: <span id="sim-status">Ready</span></p>
                            </div>
                            <div class="gesture-feedback" id="gesture-feedback">
                                <strong>Gesture:</strong> <span id="gesture-type">None</span><br>
                                <strong>Confidence:</strong> <span id="gesture-confidence">0%</span>
                            </div>
                        </div>
                    </div>
                `;

                // Setup event handlers
                this.setupEventHandlers();
            }

            setupCanvas() {
                this.mainCanvas = document.getElementById('main-canvas');
                this.physicsCanvas = document.getElementById('physics-canvas');
                this.mainCtx = this.mainCanvas.getContext('2d');
                this.physicsCtx = this.physicsCanvas.getContext('2d');

                // Set canvas size
                const resizeCanvas = () => {
                    const container = this.mainCanvas.parentElement;
                    this.mainCanvas.width = container.clientWidth;
                    this.mainCanvas.height = container.clientHeight;
                    this.physicsCanvas.width = container.clientWidth;
                    this.physicsCanvas.height = container.clientHeight;
                };

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // Start animation loop
                this.animate();
            }

            setupTouchHandlers() {
                // Touch events
                this.mainCanvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.mainCanvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.mainCanvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));

                // Mouse events (for testing)
                this.mainCanvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.mainCanvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.mainCanvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
            }

            setupEventHandlers() {
                // Mode select
                document.getElementById('mode-select').addEventListener('change', (e) => {
                    this.mode = e.target.value;
                    document.getElementById('current-mode').textContent = 
                        e.target.options[e.target.selectedIndex].text;
                });

                // Level buttons
                document.querySelectorAll('[data-level]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-level]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.level = btn.dataset.level;
                        document.getElementById('current-level').textContent = 
                            btn.dataset.level.charAt(0).toUpperCase() + btn.dataset.level.slice(1);
                    });
                });

                // Touch mode buttons
                document.querySelectorAll('[data-touch]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-touch]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.touchMode = btn.dataset.touch;
                        document.getElementById('info-mode').textContent = 
                            btn.dataset.touch.charAt(0).toUpperCase() + btn.dataset.touch.slice(1);
                    });
                });

                // Action buttons
                document.getElementById('clear-btn').addEventListener('click', () => this.clearCanvas());
                document.getElementById('simulate-btn').addEventListener('click', () => this.runSimulation());
                document.getElementById('save-btn').addEventListener('click', () => this.saveWork());
            }

            handleTouchStart(e) {
                e.preventDefault();
                const rect = this.mainCanvas.getBoundingClientRect();
                
                for (let touch of e.touches) {
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    this.touches.push({
                        id: touch.identifier,
                        x: x,
                        y: y,
                        startX: x,
                        startY: y
                    });

                    // Visual feedback
                    this.showTouchFeedback(x, y);
                }

                document.getElementById('touch-count').textContent = this.touches.length;

                if (this.touchMode === 'draw' && this.touches.length === 1) {
                    this.startDrawing(this.touches[0].x, this.touches[0].y);
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                const rect = this.mainCanvas.getBoundingClientRect();
                
                for (let touch of e.touches) {
                    const touchData = this.touches.find(t => t.id === touch.identifier);
                    if (touchData) {
                        touchData.x = touch.clientX - rect.left;
                        touchData.y = touch.clientY - rect.top;
                    }
                }

                // Handle gestures
                if (this.touches.length === 2) {
                    this.handlePinchGesture();
                } else if (this.touches.length === 1 && this.touchMode === 'draw') {
                    this.continueDrawing(this.touches[0].x, this.touches[0].y);
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    const index = this.touches.findIndex(t => t.id === touch.identifier);
                    if (index !== -1) {
                        const touchData = this.touches[index];
                        
                        if (this.touchMode === 'draw') {
                            this.endDrawing();
                        }
                        
                        this.touches.splice(index, 1);
                    }
                }

                document.getElementById('touch-count').textContent = this.touches.length;
            }

            handleMouseDown(e) {
                const rect = this.mainCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.mouseDown = true;
                
                if (this.touchMode === 'draw') {
                    this.startDrawing(x, y);
                }
                
                this.showTouchFeedback(x, y);
            }

            handleMouseMove(e) {
                if (!this.mouseDown) return;
                
                const rect = this.mainCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.touchMode === 'draw') {
                    this.continueDrawing(x, y);
                }
            }

            handleMouseUp(e) {
                this.mouseDown = false;
                
                if (this.touchMode === 'draw') {
                    this.endDrawing();
                }
            }

            startDrawing(x, y) {
                this.currentPath = [{x, y}];
                this.isDrawing = true;
            }

            continueDrawing(x, y) {
                if (!this.isDrawing) return;
                
                this.currentPath.push({x, y});
                
                // Draw on canvas
                this.mainCtx.strokeStyle = '#3498db';
                this.mainCtx.lineWidth = 3;
                this.mainCtx.lineCap = 'round';
                
                this.mainCtx.beginPath();
                this.mainCtx.moveTo(this.currentPath[this.currentPath.length - 2].x, 
                                   this.currentPath[this.currentPath.length - 2].y);
                this.mainCtx.lineTo(x, y);
                this.mainCtx.stroke();
            }

            endDrawing() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                
                // Analyze shape
                if (this.currentPath.length > 5) {
                    const shape = this.recognizeShape(this.currentPath);
                    this.shapes.push(shape);
                    document.getElementById('object-count').textContent = this.shapes.length;
                    
                    // Draw recognized shape
                    this.drawShape(shape);
                }
            }

            recognizeShape(path) {
                // Simple shape recognition
                const startPoint = path[0];
                const endPoint = path[path.length - 1];
                const distance = Math.sqrt(
                    Math.pow(endPoint.x - startPoint.x, 2) + 
                    Math.pow(endPoint.y - startPoint.y, 2)
                );
                
                let type = 'freeform';
                
                if (distance < 30) {
                    // Closed shape - might be circle or polygon
                    type = 'circle';
                } else {
                    // Open shape - might be line
                    type = 'line';
                }
                
                return {
                    type: type,
                    path: path,
                    center: this.getPathCenter(path),
                    radius: this.getPathRadius(path)
                };
            }

            getPathCenter(path) {
                let sumX = 0, sumY = 0;
                path.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                });
                return {
                    x: sumX / path.length,
                    y: sumY / path.length
                };
            }

            getPathRadius(path) {
                const center = this.getPathCenter(path);
                let sumDist = 0;
                path.forEach(p => {
                    sumDist += Math.sqrt(
                        Math.pow(p.x - center.x, 2) + 
                        Math.pow(p.y - center.y, 2)
                    );
                });
                return sumDist / path.length;
            }

            drawShape(shape) {
                this.mainCtx.strokeStyle = '#2ecc71';
                this.mainCtx.lineWidth = 2;
                
                if (shape.type === 'circle') {
                    this.mainCtx.beginPath();
                    this.mainCtx.arc(shape.center.x, shape.center.y, shape.radius, 0, Math.PI * 2);
                    this.mainCtx.stroke();
                } else if (shape.type === 'line') {
                    this.mainCtx.beginPath();
                    this.mainCtx.moveTo(shape.path[0].x, shape.path[0].y);
                    this.mainCtx.lineTo(shape.path[shape.path.length - 1].x, 
                                       shape.path[shape.path.length - 1].y);
                    this.mainCtx.stroke();
                }
            }

            handlePinchGesture() {
                if (this.touches.length !== 2) return;
                
                const touch1 = this.touches[0];
                const touch2 = this.touches[1];
                
                const distance = Math.sqrt(
                    Math.pow(touch2.x - touch1.x, 2) + 
                    Math.pow(touch2.y - touch1.y, 2)
                );
                
                if (this.lastPinchDistance) {
                    const scale = distance / this.lastPinchDistance;
                    
                    if (scale > 1.1) {
                        this.updateGestureFeedback('SPREAD', 90);
                    } else if (scale < 0.9) {
                        this.updateGestureFeedback('PINCH', 90);
                    }
                }
                
                this.lastPinchDistance = distance;
            }

            showTouchFeedback(x, y) {
                const feedback = document.createElement('div');
                feedback.className = 'touch-point';
                feedback.style.left = x + 'px';
                feedback.style.top = y + 'px';
                this.mainCanvas.parentElement.appendChild(feedback);
                
                setTimeout(() => feedback.remove(), 600);
            }

            updateGestureFeedback(gesture, confidence) {
                document.getElementById('gesture-type').textContent = gesture;
                document.getElementById('gesture-confidence').textContent = confidence + '%';
            }

            clearCanvas() {
                this.mainCtx.clearRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
                this.physicsCtx.clearRect(0, 0, this.physicsCanvas.width, this.physicsCanvas.height);
                this.shapes = [];
                document.getElementById('object-count').textContent = '0';
            }

            async runSimulation() {
                document.getElementById('sim-status').textContent = 'Running...';
                
                // Send to LOLA server
                try {
                    const response = await fetch(this.lolaServerUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            action: 'emulate',
                            state: this.shapes.map(s => s.radius || 50),
                            steps: 20
                        })
                    });
                    
                    const result = await response.json();
                    console.log('LOLA Simulation Result:', result);
                    
                    // Visualize physics
                    this.visualizePhysics(result.result);
                    
                } catch (error) {
                    console.warn('LOLA Server error, using local simulation');
                    this.runLocalSimulation();
                }
                
                setTimeout(() => {
                    document.getElementById('sim-status').textContent = 'Complete';
                }, 2000);
            }

            visualizePhysics(trajectory) {
                let frame = 0;
                
                const animate = () => {
                    if (frame >= trajectory.length) return;
                    
                    this.physicsCtx.clearRect(0, 0, this.physicsCanvas.width, this.physicsCanvas.height);
                    
                    const data = trajectory[frame];
                    
                    // Draw physics visualization
                    this.physicsCtx.fillStyle = 'rgba(52, 152, 219, 0.5)';
                    
                    data.forEach((value, index) => {
                        const x = (index / data.length) * this.physicsCanvas.width;
                        const y = this.physicsCanvas.height / 2 + value * 50;
                        
                        this.physicsCtx.beginPath();
                        this.physicsCtx.arc(x, y, 5, 0, Math.PI * 2);
                        this.physicsCtx.fill();
                    });
                    
                    frame++;
                    requestAnimationFrame(animate);
                };
                
                animate();
            }

            runLocalSimulation() {
                // Simple local physics simulation
                const frames = 20;
                const trajectory = [];
                
                for (let i = 0; i < frames; i++) {
                    const data = [];
                    for (let j = 0; j < 10; j++) {
                        data.push(Math.sin((j + i) * 0.5) * Math.cos(i * 0.1));
                    }
                    trajectory.push(data);
                }
                
                this.visualizePhysics(trajectory);
            }

            saveWork() {
                const data = {
                    mode: this.mode,
                    level: this.level,
                    shapes: this.shapes,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lola-math-${Date.now()}.json`;
                a.click();
            }

            animate() {
                // Update FPS
                if (!this.lastTime) this.lastTime = performance.now();
                const now = performance.now();
                const delta = now - this.lastTime;
                const fps = Math.round(1000 / delta);
                
                if (now - this.lastFPSUpdate > 500) {
                    document.getElementById('fps').textContent = fps;
                    this.lastFPSUpdate = now;
                }
                
                this.lastTime = now;
                
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize platform
        window.addEventListener('DOMContentLoaded', () => {
            new LOLAMathPlatform();
        });
    </script>
</body>
</html>
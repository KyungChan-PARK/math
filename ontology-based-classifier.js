// Palantir Ontology 기반 파일 분류 시스템
// Ontology-Based File Classification System for Claude-Qwen Collaboration

import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { MongoClient } from 'mongodb';
import neo4j from 'neo4j-driver';
import chalk from 'chalk';

/**
 * Palantir Ontology 핵심 개념:
 * 1. Object Types (객체 타입): 실세계 엔티티의 스키마 정의
 * 2. Properties (속성): 객체 타입의 특성
 * 3. Link Types (연결 타입): 객체 간 관계 정의
 * 4. Object Sets (객체 집합): 객체들의 그룹
 * 5. Actions: 객체에 대한 작업
 */

class PalantirOntologyClassifier {
    constructor(projectPath) {
        this.projectPath = projectPath;
        
        // MongoDB 연결 (메타데이터 저장)
        this.mongoUri = 'mongodb://localhost:27017/mathDB';
        
        // Neo4j 연결 (관계 그래프)
        this.neo4jUri = 'bolt://localhost:7687';
        this.neo4jDriver = null;
        
        // Ontology 정의
        this.ontology = {
            // 객체 타입 정의
            objectTypes: {
                'SourceFile': {
                    properties: {
                        fileName: 'string',
                        filePath: 'string',
                        extension: 'string',
                        size: 'number',
                        hash: 'string',
                        created: 'datetime',
                        modified: 'datetime',
                        language: 'string',
                        purpose: 'string',
                        complexity: 'number',
                        dependencies: 'array'
                    }
                },
                'Documentation': {
                    properties: {
                        title: 'string',
                        type: 'string', // API, Guide, Reference, etc.
                        format: 'string', // MD, TXT, PDF
                        topics: 'array',
                        references: 'array',
                        lastUpdated: 'datetime',
                        autoGenerated: 'boolean'
                    }
                },
                'Function': {
                    properties: {
                        name: 'string',
                        parameters: 'array',
                        returnType: 'string',
                        description: 'string',
                        category: 'string',
                        isExported: 'boolean',
                        isAsync: 'boolean',
                        complexity: 'number'
                    }
                },
                'AIAgent': {
                    properties: {
                        agentId: 'string',
                        name: 'string',
                        category: 'string',
                        capabilities: 'array',
                        complexity: 'string',
                        model: 'string'
                    }
                },
                'APIEndpoint': {
                    properties: {
                        path: 'string',
                        method: 'string',
                        parameters: 'array',
                        responseType: 'string',
                        authentication: 'boolean',
                        rateLimit: 'number'
                    }
                },
                'TestCase': {
                    properties: {
                        name: 'string',
                        targetFile: 'string',
                        type: 'string', // unit, integration, e2e
                        status: 'string',
                        coverage: 'number'
                    }
                },
                'Configuration': {
                    properties: {
                        name: 'string',
                        environment: 'string',
                        values: 'object',
                        sensitive: 'boolean'
                    }
                }
            },
            
            // 연결 타입 정의 (관계)
            linkTypes: {
                'IMPORTS': {
                    from: 'SourceFile',
                    to: 'SourceFile',
                    properties: {
                        importType: 'string', // default, named, namespace
                        alias: 'string'
                    }
                },
                'DOCUMENTS': {
                    from: 'Documentation',
                    to: ['SourceFile', 'Function', 'AIAgent'],
                    properties: {
                        section: 'string',
                        autoUpdated: 'boolean'
                    }
                },
                'CALLS': {
                    from: ['Function', 'AIAgent'],
                    to: ['Function', 'APIEndpoint'],
                    properties: {
                        frequency: 'number',
                        isAsync: 'boolean'
                    }
                },
                'TESTS': {
                    from: 'TestCase',
                    to: ['SourceFile', 'Function'],
                    properties: {
                        coverage: 'number',
                        lastRun: 'datetime'
                    }
                },
                'CONFIGURES': {
                    from: 'Configuration',
                    to: ['SourceFile', 'AIAgent'],
                    properties: {
                        required: 'boolean'
                    }
                },
                'REFERENCES': {
                    from: 'Documentation',
                    to: 'Documentation',
                    properties: {
                        referenceType: 'string' // see-also, extends, replaces
                    }
                },
                'COLLABORATES_WITH': {
                    from: 'AIAgent',
                    to: 'AIAgent',
                    properties: {
                        collaborationType: 'string', // sequential, parallel, hybrid
                        frequency: 'number'
                    }
                }
            },
            
            // 액션 정의
            actions: {
                'classify': 'Classify file into ontology',
                'analyze': 'Deep analysis of file content',
                'link': 'Create relationships between objects',
                'update': 'Update object properties',
                'query': 'Query objects and relationships'
            }
        };
        
        // 분석 결과 캐시
        this.analysisCache = new Map();
        
        // 파일 파서 매핑
        this.parsers = {
            '.js': this.parseJavaScript.bind(this),
            '.ts': this.parseTypeScript.bind(this),
            '.jsx': this.parseJSX.bind(this),
            '.tsx': this.parseTSX.bind(this),
            '.md': this.parseMarkdown.bind(this),
            '.json': this.parseJSON.bind(this),
            '.yml': this.parseYAML.bind(this),
            '.yaml': this.parseYAML.bind(this)
        };
    }
    
    // 시스템 초기화
    async initialize() {
        console.log(chalk.cyan('🚀 Initializing Palantir Ontology Classifier...'));
        
        // MongoDB 연결
        try {
            this.mongoClient = new MongoClient(this.mongoUri);
            await this.mongoClient.connect();
            this.db = this.mongoClient.db('mathDB');
            this.objectsCollection = this.db.collection('ontology_objects');
            this.linksCollection = this.db.collection('ontology_links');
            console.log(chalk.green('  ✓ MongoDB connected'));
        } catch (error) {
            console.log(chalk.yellow('  ⚠ MongoDB not available, using in-memory storage'));
            this.useInMemoryStorage();
        }
        
        // Neo4j 연결
        try {
            this.neo4jDriver = neo4j.driver(
                this.neo4jUri,
                neo4j.auth.basic('neo4j', 'password')
            );
            await this.neo4jDriver.verifyConnectivity();
            console.log(chalk.green('  ✓ Neo4j connected'));
        } catch (error) {
            console.log(chalk.yellow('  ⚠ Neo4j not available, using simplified graph'));
            this.useSimplifiedGraph();
        }
        
        // 인덱스 생성
        await this.createIndexes();
        
        console.log(chalk.green('✅ Ontology system initialized'));
    }
    
    // In-memory 스토리지 대체
    useInMemoryStorage() {
        this.inMemoryObjects = new Map();
        this.inMemoryLinks = [];
        this.objectsCollection = {
            insertOne: async (doc) => {
                this.inMemoryObjects.set(doc._id, doc);
                return { insertedId: doc._id };
            },
            findOne: async (query) => {
                for (const [id, obj] of this.inMemoryObjects) {
                    if (this.matchQuery(obj, query)) return obj;
                }
                return null;
            },
            find: (query) => ({
                toArray: async () => {
                    const results = [];
                    for (const [id, obj] of this.inMemoryObjects) {
                        if (this.matchQuery(obj, query)) results.push(obj);
                    }
                    return results;
                }
            }),
            updateOne: async (filter, update) => {
                for (const [id, obj] of this.inMemoryObjects) {
                    if (this.matchQuery(obj, filter)) {
                        Object.assign(obj, update.$set || {});
                        return { modifiedCount: 1 };
                    }
                }
                return { modifiedCount: 0 };
            }
        };
        
        this.linksCollection = {
            insertOne: async (doc) => {
                this.inMemoryLinks.push(doc);
                return { insertedId: doc._id };
            },
            find: (query) => ({
                toArray: async () => {
                    return this.inMemoryLinks.filter(link => this.matchQuery(link, query));
                }
            })
        };
    }
    
    // 간단한 쿼리 매칭
    matchQuery(obj, query) {
        for (const [key, value] of Object.entries(query)) {
            if (obj[key] !== value) return false;
        }
        return true;
    }
    
    // 단순화된 그래프 사용
    useSimplifiedGraph() {
        this.simpleGraph = {
            nodes: new Map(),
            edges: []
        };
    }
    
    // 인덱스 생성
    async createIndexes() {
        if (this.objectsCollection.createIndex) {
            await this.objectsCollection.createIndex({ type: 1 });
            await this.objectsCollection.createIndex({ 'properties.fileName': 1 });
            await this.objectsCollection.createIndex({ 'properties.hash': 1 });
        }
    }
    
    // 파일 분류 및 분석
    async classifyFile(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        const stat = fs.statSync(filePath);
        const content = fs.readFileSync(filePath, 'utf-8');
        const hash = crypto.createHash('md5').update(content).digest('hex');
        
        // 캐시 확인
        if (this.analysisCache.has(hash)) {
            return this.analysisCache.get(hash);
        }
        
        // 기본 객체 생성
        const baseObject = {
            _id: hash,
            type: this.determineObjectType(filePath, content),
            properties: {
                fileName: path.basename(filePath),
                filePath: filePath,
                extension: ext,
                size: stat.size,
                hash: hash,
                created: stat.birthtime,
                modified: stat.mtime
            }
        };
        
        // 파일 타입별 상세 분석
        if (this.parsers[ext]) {
            const analysis = await this.parsers[ext](content, filePath);
            Object.assign(baseObject.properties, analysis);
        }
        
        // 의미론적 분석
        const semanticAnalysis = await this.analyzeSemantics(content, baseObject.type);
        baseObject.semantics = semanticAnalysis;
        
        // 캐시 저장
        this.analysisCache.set(hash, baseObject);
        
        // DB 저장
        await this.saveObject(baseObject);
        
        return baseObject;
    }
    
    // 객체 타입 결정
    determineObjectType(filePath, content) {
        const fileName = path.basename(filePath);
        const ext = path.extname(filePath).toLowerCase();
        
        // 테스트 파일
        if (fileName.includes('test') || fileName.includes('spec')) {
            return 'TestCase';
        }
        
        // 문서 파일
        if (['.md', '.txt', '.pdf'].includes(ext)) {
            return 'Documentation';
        }
        
        // 설정 파일
        if (['.json', '.yml', '.yaml', '.env'].includes(ext) || fileName.includes('config')) {
            return 'Configuration';
        }
        
        // AI Agent 파일
        if (content.includes('agent') || content.includes('Agent')) {
            return 'AIAgent';
        }
        
        // API 엔드포인트
        if (content.includes('app.get') || content.includes('app.post') || content.includes('router.')) {
            return 'APIEndpoint';
        }
        
        // 기본: 소스 파일
        return 'SourceFile';
    }
    
    // JavaScript 파일 파싱
    async parseJavaScript(content, filePath) {
        const analysis = {
            language: 'JavaScript',
            functions: [],
            imports: [],
            exports: [],
            classes: [],
            dependencies: []
        };
        
        // Import 문 추출
        const importRegex = /import\s+(?:{[^}]+}|\*\s+as\s+\w+|\w+)\s+from\s+['"]([^'"]+)['"]/g;
        let match;
        while ((match = importRegex.exec(content)) !== null) {
            analysis.imports.push({
                module: match[1],
                line: content.substring(0, match.index).split('\n').length
            });
            analysis.dependencies.push(match[1]);
        }
        
        // Require 문 추출
        const requireRegex = /require\(['"]([^'"]+)['"]\)/g;
        while ((match = requireRegex.exec(content)) !== null) {
            analysis.imports.push({
                module: match[1],
                line: content.substring(0, match.index).split('\n').length
            });
            analysis.dependencies.push(match[1]);
        }
        
        // 함수 추출
        const functionRegex = /(?:async\s+)?function\s+(\w+)\s*\([^)]*\)|(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s+)?\([^)]*\)\s*=>/g;
        while ((match = functionRegex.exec(content)) !== null) {
            const funcName = match[1] || match[2];
            analysis.functions.push({
                name: funcName,
                isAsync: match[0].includes('async'),
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // 클래스 추출
        const classRegex = /class\s+(\w+)(?:\s+extends\s+(\w+))?\s*{/g;
        while ((match = classRegex.exec(content)) !== null) {
            analysis.classes.push({
                name: match[1],
                extends: match[2] || null,
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // Export 문 추출
        const exportRegex = /export\s+(?:default\s+)?(?:{[^}]+}|class\s+\w+|function\s+\w+|const\s+\w+|let\s+\w+|var\s+\w+)/g;
        while ((match = exportRegex.exec(content)) !== null) {
            analysis.exports.push({
                statement: match[0],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // 복잡도 계산
        analysis.complexity = this.calculateComplexity(content);
        
        // 목적 추론
        analysis.purpose = this.inferPurpose(filePath, content, analysis);
        
        return analysis;
    }
    
    // TypeScript 파일 파싱
    async parseTypeScript(content, filePath) {
        // JavaScript 파싱 확장
        const jsAnalysis = await this.parseJavaScript(content, filePath);
        
        // TypeScript 특정 요소 추가
        const analysis = {
            ...jsAnalysis,
            language: 'TypeScript',
            interfaces: [],
            types: [],
            enums: []
        };
        
        // Interface 추출
        const interfaceRegex = /interface\s+(\w+)(?:\s+extends\s+([^{]+))?\s*{/g;
        let match;
        while ((match = interfaceRegex.exec(content)) !== null) {
            analysis.interfaces.push({
                name: match[1],
                extends: match[2] ? match[2].trim().split(',').map(s => s.trim()) : [],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // Type alias 추출
        const typeRegex = /type\s+(\w+)\s*=\s*([^;]+);/g;
        while ((match = typeRegex.exec(content)) !== null) {
            analysis.types.push({
                name: match[1],
                definition: match[2].trim(),
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // Enum 추출
        const enumRegex = /enum\s+(\w+)\s*{/g;
        while ((match = enumRegex.exec(content)) !== null) {
            analysis.enums.push({
                name: match[1],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        return analysis;
    }
    
    // JSX 파일 파싱
    async parseJSX(content, filePath) {
        const jsAnalysis = await this.parseJavaScript(content, filePath);
        
        return {
            ...jsAnalysis,
            language: 'JSX',
            components: this.extractReactComponents(content)
        };
    }
    
    // TSX 파일 파싱
    async parseTSX(content, filePath) {
        const tsAnalysis = await this.parseTypeScript(content, filePath);
        
        return {
            ...tsAnalysis,
            language: 'TSX',
            components: this.extractReactComponents(content)
        };
    }
    
    // React 컴포넌트 추출
    extractReactComponents(content) {
        const components = [];
        
        // 함수형 컴포넌트
        const funcCompRegex = /(?:export\s+)?(?:const|function)\s+([A-Z]\w+)\s*[=:]/g;
        let match;
        while ((match = funcCompRegex.exec(content)) !== null) {
            components.push({
                name: match[1],
                type: 'functional',
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // 클래스형 컴포넌트
        const classCompRegex = /class\s+([A-Z]\w+)\s+extends\s+(?:React\.)?(?:Component|PureComponent)/g;
        while ((match = classCompRegex.exec(content)) !== null) {
            components.push({
                name: match[1],
                type: 'class',
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        return components;
    }
    
    // Markdown 파일 파싱
    async parseMarkdown(content, filePath) {
        const analysis = {
            format: 'Markdown',
            headings: [],
            links: [],
            codeBlocks: [],
            images: []
        };
        
        // 제목 추출
        const headingRegex = /^(#{1,6})\s+(.+)$/gm;
        let match;
        while ((match = headingRegex.exec(content)) !== null) {
            analysis.headings.push({
                level: match[1].length,
                text: match[2],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // 링크 추출
        const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
        while ((match = linkRegex.exec(content)) !== null) {
            analysis.links.push({
                text: match[1],
                url: match[2],
                isInternal: !match[2].startsWith('http')
            });
        }
        
        // 코드 블록 추출
        const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
        while ((match = codeBlockRegex.exec(content)) !== null) {
            analysis.codeBlocks.push({
                language: match[1] || 'plain',
                content: match[2],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // 이미지 추출
        const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
        while ((match = imageRegex.exec(content)) !== null) {
            analysis.images.push({
                alt: match[1],
                src: match[2]
            });
        }
        
        // 토픽 추출 (제목 기반)
        analysis.topics = analysis.headings
            .filter(h => h.level <= 2)
            .map(h => h.text);
        
        return analysis;
    }
    
    // JSON 파일 파싱
    async parseJSON(content, filePath) {
        try {
            const data = JSON.parse(content);
            
            return {
                format: 'JSON',
                isValid: true,
                keys: Object.keys(data),
                structure: this.analyzeJSONStructure(data),
                isConfig: path.basename(filePath).includes('config') || 
                         path.basename(filePath) === 'package.json'
            };
        } catch (error) {
            return {
                format: 'JSON',
                isValid: false,
                error: error.message
            };
        }
    }
    
    // YAML 파일 파싱
    async parseYAML(content, filePath) {
        // 간단한 YAML 분석 (실제로는 yaml 라이브러리 사용 권장)
        return {
            format: 'YAML',
            lines: content.split('\n').length,
            isConfig: true
        };
    }
    
    // JSON 구조 분석
    analyzeJSONStructure(obj, depth = 0, maxDepth = 3) {
        if (depth > maxDepth) return '...';
        
        if (Array.isArray(obj)) {
            return obj.length > 0 ? 
                [`Array(${obj.length})`, this.analyzeJSONStructure(obj[0], depth + 1, maxDepth)] :
                'Array(0)';
        }
        
        if (obj && typeof obj === 'object') {
            const structure = {};
            for (const [key, value] of Object.entries(obj)) {
                structure[key] = typeof value === 'object' ? 
                    this.analyzeJSONStructure(value, depth + 1, maxDepth) :
                    typeof value;
            }
            return structure;
        }
        
        return typeof obj;
    }
    
    // 복잡도 계산
    calculateComplexity(content) {
        let complexity = 0;
        
        // 조건문
        complexity += (content.match(/\bif\b/g) || []).length;
        complexity += (content.match(/\belse\b/g) || []).length;
        complexity += (content.match(/\bswitch\b/g) || []).length;
        complexity += (content.match(/\bcase\b/g) || []).length;
        
        // 반복문
        complexity += (content.match(/\bfor\b/g) || []).length;
        complexity += (content.match(/\bwhile\b/g) || []).length;
        complexity += (content.match(/\bdo\b/g) || []).length;
        
        // 예외 처리
        complexity += (content.match(/\btry\b/g) || []).length;
        complexity += (content.match(/\bcatch\b/g) || []).length;
        
        // 논리 연산자
        complexity += (content.match(/&&/g) || []).length;
        complexity += (content.match(/\|\|/g) || []).length;
        
        return complexity;
    }
    
    // 목적 추론
    inferPurpose(filePath, content, analysis) {
        const fileName = path.basename(filePath).toLowerCase();
        
        // 파일명 기반 추론
        if (fileName.includes('test')) return 'Testing';
        if (fileName.includes('config')) return 'Configuration';
        if (fileName.includes('util') || fileName.includes('helper')) return 'Utility';
        if (fileName.includes('component')) return 'UI Component';
        if (fileName.includes('service')) return 'Service Layer';
        if (fileName.includes('model')) return 'Data Model';
        if (fileName.includes('controller')) return 'Controller';
        if (fileName.includes('route')) return 'Routing';
        if (fileName.includes('middleware')) return 'Middleware';
        
        // 내용 기반 추론
        if (analysis.classes && analysis.classes.length > 0) {
            if (analysis.classes.some(c => c.extends && c.extends.includes('Component'))) {
                return 'React Component';
            }
        }
        
        if (content.includes('app.get') || content.includes('app.post')) {
            return 'API Server';
        }
        
        if (content.includes('mongoose') || content.includes('sequelize')) {
            return 'Database Model';
        }
        
        return 'General Purpose';
    }
    
    // 의미론적 분석
    async analyzeSemantics(content, objectType) {
        const semantics = {
            keywords: [],
            entities: [],
            intents: [],
            domain: null
        };
        
        // 키워드 추출 (간단한 버전)
        const keywords = new Set();
        
        // 프로그래밍 관련 키워드
        const progKeywords = ['async', 'await', 'promise', 'callback', 'stream', 'buffer', 
                              'api', 'rest', 'graphql', 'websocket', 'database', 'cache'];
        progKeywords.forEach(kw => {
            if (content.toLowerCase().includes(kw)) {
                keywords.add(kw);
            }
        });
        
        // AI/ML 관련 키워드
        const aiKeywords = ['agent', 'model', 'training', 'inference', 'neural', 'embedding',
                           'claude', 'qwen', 'gpt', 'llm', 'prompt', 'completion'];
        aiKeywords.forEach(kw => {
            if (content.toLowerCase().includes(kw)) {
                keywords.add(kw);
            }
        });
        
        semantics.keywords = Array.from(keywords);
        
        // 도메인 추론
        if (semantics.keywords.some(k => aiKeywords.includes(k))) {
            semantics.domain = 'AI/ML';
        } else if (semantics.keywords.includes('api') || semantics.keywords.includes('rest')) {
            semantics.domain = 'Backend';
        } else if (content.includes('React') || content.includes('Component')) {
            semantics.domain = 'Frontend';
        } else if (objectType === 'TestCase') {
            semantics.domain = 'Testing';
        } else if (objectType === 'Documentation') {
            semantics.domain = 'Documentation';
        }
        
        return semantics;
    }
    
    // 객체 저장
    async saveObject(object) {
        try {
            const existing = await this.objectsCollection.findOne({ _id: object._id });
            if (existing) {
                await this.objectsCollection.updateOne(
                    { _id: object._id },
                    { $set: object }
                );
            } else {
                await this.objectsCollection.insertOne(object);
            }
        } catch (error) {
            console.error('Error saving object:', error);
        }
    }
    
    // 관계 생성
    async createLink(fromId, toId, linkType, properties = {}) {
        const link = {
            _id: `${fromId}-${linkType}-${toId}`,
            from: fromId,
            to: toId,
            type: linkType,
            properties: properties,
            created: new Date()
        };
        
        try {
            await this.linksCollection.insertOne(link);
            
            // Neo4j에도 저장 (가능한 경우)
            if (this.neo4jDriver) {
                const session = this.neo4jDriver.session();
                await session.run(
                    `MATCH (a {id: $fromId}), (b {id: $toId})
                     MERGE (a)-[r:${linkType}]->(b)
                     SET r = $properties`,
                    { fromId, toId, properties }
                );
                await session.close();
            }
        } catch (error) {
            console.error('Error creating link:', error);
        }
    }
    
    // 전체 프로젝트 스캔 및 분류
    async scanProject() {
        console.log(chalk.cyan('🔍 Scanning entire project...'));
        
        const startTime = Date.now();
        const results = {
            processed: 0,
            objects: {},
            links: [],
            errors: []
        };
        
        // 재귀적 파일 스캔
        const scanDir = async (dir) => {
            const files = fs.readdirSync(dir);
            
            for (const file of files) {
                const fullPath = path.join(dir, file);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory()) {
                    // 제외할 디렉토리
                    if (!['node_modules', '.git', '.venv', 'venv', '__pycache__'].includes(file)) {
                        await scanDir(fullPath);
                    }
                } else {
                    try {
                        const object = await this.classifyFile(fullPath);
                        results.processed++;
                        
                        if (!results.objects[object.type]) {
                            results.objects[object.type] = [];
                        }
                        results.objects[object.type].push(object);
                        
                        // 진행 상황 출력
                        if (results.processed % 100 === 0) {
                            console.log(chalk.gray(`  Processed ${results.processed} files...`));
                        }
                    } catch (error) {
                        results.errors.push({
                            file: fullPath,
                            error: error.message
                        });
                    }
                }
            }
        };
        
        await scanDir(this.projectPath);
        
        // 관계 분석
        console.log(chalk.cyan('🔗 Analyzing relationships...'));
        await this.analyzeRelationships(results.objects);
        
        const endTime = Date.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);
        
        console.log(chalk.green(`\n✅ Scan complete!`));
        console.log(chalk.white(`  Processed: ${results.processed} files`));
        console.log(chalk.white(`  Duration: ${duration}s`));
        console.log(chalk.white(`  Errors: ${results.errors.length}`));
        
        // 통계 출력
        console.log(chalk.cyan('\n📊 Object Type Distribution:'));
        for (const [type, objects] of Object.entries(results.objects)) {
            console.log(chalk.white(`  ${type}: ${objects.length}`));
        }
        
        return results;
    }
    
    // 관계 분석
    async analyzeRelationships(objects) {
        // Import 관계 분석
        for (const sourceFiles of Object.values(objects)) {
            for (const file of sourceFiles) {
                if (file.properties.dependencies) {
                    for (const dep of file.properties.dependencies) {
                        // 내부 의존성 찾기
                        const targetFile = await this.findFileByImport(dep, objects);
                        if (targetFile) {
                            await this.createLink(
                                file._id,
                                targetFile._id,
                                'IMPORTS',
                                { module: dep }
                            );
                        }
                    }
                }
            }
        }
        
        // 문서 관계 분석
        if (objects.Documentation) {
            for (const doc of objects.Documentation) {
                if (doc.properties.references) {
                    for (const ref of doc.properties.references) {
                        const targetDoc = await this.findDocByReference(ref, objects);
                        if (targetDoc) {
                            await this.createLink(
                                doc._id,
                                targetDoc._id,
                                'REFERENCES',
                                { referenceType: 'see-also' }
                            );
                        }
                    }
                }
            }
        }
        
        // 테스트 관계 분석
        if (objects.TestCase) {
            for (const test of objects.TestCase) {
                const targetFile = await this.findTestTarget(test, objects);
                if (targetFile) {
                    await this.createLink(
                        test._id,
                        targetFile._id,
                        'TESTS',
                        { coverage: test.properties.coverage || 0 }
                    );
                }
            }
        }
    }
    
    // Import로 파일 찾기
    async findFileByImport(importPath, objects) {
        // 상대 경로 처리
        if (importPath.startsWith('./') || importPath.startsWith('../')) {
            // 실제 경로 계산 로직 필요
            return null;
        }
        
        // 절대 경로 또는 모듈명
        for (const files of Object.values(objects)) {
            for (const file of files) {
                if (file.properties.fileName.includes(importPath)) {
                    return file;
                }
            }
        }
        
        return null;
    }
    
    // 참조로 문서 찾기
    async findDocByReference(reference, objects) {
        if (!objects.Documentation) return null;
        
        for (const doc of objects.Documentation) {
            if (doc.properties.fileName === reference || 
                doc.properties.title === reference) {
                return doc;
            }
        }
        
        return null;
    }
    
    // 테스트 대상 찾기
    async findTestTarget(test, objects) {
        const testFileName = test.properties.fileName;
        const targetName = testFileName
            .replace('.test.', '.')
            .replace('-test.', '.')
            .replace('test-', '');
        
        for (const files of Object.values(objects)) {
            for (const file of files) {
                if (file.properties.fileName === targetName) {
                    return file;
                }
            }
        }
        
        return null;
    }
    
    // 쿼리 실행
    async query(queryObj) {
        const results = await this.objectsCollection.find(queryObj).toArray();
        return results;
    }
    
    // Claude-Qwen 협업을 위한 컨텍스트 생성
    async generateCollaborationContext(taskType) {
        const context = {
            timestamp: new Date().toISOString(),
            taskType: taskType,
            relevantObjects: [],
            relationships: [],
            recommendations: []
        };
        
        // 작업 타입에 따른 관련 객체 수집
        switch (taskType) {
            case 'code-review':
                context.relevantObjects = await this.query({
                    type: 'SourceFile',
                    'properties.modified': { $gte: new Date(Date.now() - 24*60*60*1000) }
                });
                break;
                
            case 'documentation':
                context.relevantObjects = await this.query({
                    type: { $in: ['Documentation', 'APIEndpoint'] }
                });
                break;
                
            case 'testing':
                context.relevantObjects = await this.query({
                    type: 'TestCase'
                });
                break;
                
            case 'architecture':
                context.relevantObjects = await this.query({
                    type: { $in: ['SourceFile', 'AIAgent', 'APIEndpoint'] }
                });
                break;
        }
        
        // 관계 수집
        for (const obj of context.relevantObjects) {
            const links = await this.linksCollection.find({
                $or: [{ from: obj._id }, { to: obj._id }]
            }).toArray();
            context.relationships.push(...links);
        }
        
        // 추천 생성
        context.recommendations = this.generateRecommendations(context);
        
        return context;
    }
    
    // 추천 생성
    generateRecommendations(context) {
        const recommendations = [];
        
        // 중복 파일 제거 추천
        const duplicates = new Map();
        context.relevantObjects.forEach(obj => {
            const key = obj.properties.hash;
            if (duplicates.has(key)) {
                recommendations.push({
                    type: 'remove-duplicate',
                    priority: 'high',
                    files: [duplicates.get(key), obj._id]
                });
            } else {
                duplicates.set(key, obj._id);
            }
        });
        
        // 문서화 필요 추천
        const undocumented = context.relevantObjects.filter(obj => 
            obj.type === 'SourceFile' && 
            !context.relationships.some(link => 
                link.type === 'DOCUMENTS' && link.to === obj._id
            )
        );
        
        if (undocumented.length > 0) {
            recommendations.push({
                type: 'add-documentation',
                priority: 'medium',
                files: undocumented.map(o => o._id)
            });
        }
        
        // 테스트 커버리지 추천
        const untested = context.relevantObjects.filter(obj =>
            obj.type === 'SourceFile' &&
            !context.relationships.some(link =>
                link.type === 'TESTS' && link.to === obj._id
            )
        );
        
        if (untested.length > 0) {
            recommendations.push({
                type: 'add-tests',
                priority: 'medium',
                files: untested.map(o => o._id)
            });
        }
        
        return recommendations;
    }
    
    // 시스템 종료
    async shutdown() {
        console.log(chalk.yellow('\n🛑 Shutting down Ontology Classifier...'));
        
        if (this.mongoClient) {
            await this.mongoClient.close();
        }
        
        if (this.neo4jDriver) {
            await this.neo4jDriver.close();
        }
        
        console.log(chalk.green('✅ Shutdown complete'));
    }
}

// 메인 실행
async function main() {
    const projectPath = 'C:\\palantir\\math';
    const classifier = new PalantirOntologyClassifier(projectPath);
    
    console.log(chalk.cyan.bold('🚀 Palantir Ontology-Based File Classification System'));
    console.log(chalk.gray('=====================================================\n'));
    
    try {
        // 초기화
        await classifier.initialize();
        
        // 프로젝트 스캔
        const results = await classifier.scanProject();
        
        // 결과 저장
        const reportPath = path.join(projectPath, 'ontology-classification-report.json');
        fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
        console.log(chalk.green(`\n📄 Report saved to: ${reportPath}`));
        
        // Claude-Qwen 협업 컨텍스트 생성
        console.log(chalk.cyan('\n🤝 Generating Claude-Qwen collaboration contexts...'));
        
        const contexts = {};
        for (const taskType of ['code-review', 'documentation', 'testing', 'architecture']) {
            contexts[taskType] = await classifier.generateCollaborationContext(taskType);
            console.log(chalk.white(`  ✓ ${taskType}: ${contexts[taskType].relevantObjects.length} objects`));
        }
        
        // 협업 컨텍스트 저장
        const contextPath = path.join(projectPath, 'claude-qwen-context.json');
        fs.writeFileSync(contextPath, JSON.stringify(contexts, null, 2));
        console.log(chalk.green(`\n📄 Collaboration context saved to: ${contextPath}`));
        
        // 종료
        await classifier.shutdown();
        
    } catch (error) {
        console.error(chalk.red('❌ Error:'), error);
        await classifier.shutdown();
        process.exit(1);
    }
}

// 실행
if (require.main === module) {
    main().catch(console.error);
}

export default PalantirOntologyClassifier;
// Palantir Ontology ê¸°ë°˜ íŒŒì¼ ë¶„ë¥˜ ì‹œìŠ¤í…œ
// Ontology-Based File Classification System for Claude-Qwen Collaboration

import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { MongoClient } from 'mongodb';
import neo4j from 'neo4j-driver';
import chalk from 'chalk';

/**
 * Palantir Ontology í•µì‹¬ ê°œë…:
 * 1. Object Types (ê°ì²´ íƒ€ì…): ì‹¤ì„¸ê³„ ì—”í‹°í‹°ì˜ ìŠ¤í‚¤ë§ˆ ì •ì˜
 * 2. Properties (ì†ì„±): ê°ì²´ íƒ€ì…ì˜ íŠ¹ì„±
 * 3. Link Types (ì—°ê²° íƒ€ì…): ê°ì²´ ê°„ ê´€ê³„ ì •ì˜
 * 4. Object Sets (ê°ì²´ ì§‘í•©): ê°ì²´ë“¤ì˜ ê·¸ë£¹
 * 5. Actions: ê°ì²´ì— ëŒ€í•œ ì‘ì—…
 */

class PalantirOntologyClassifier {
    constructor(projectPath) {
        this.projectPath = projectPath;
        
        // MongoDB ì—°ê²° (ë©”íƒ€ë°ì´í„° ì €ì¥)
        this.mongoUri = 'mongodb://localhost:27017/mathDB';
        
        // Neo4j ì—°ê²° (ê´€ê³„ ê·¸ë˜í”„)
        this.neo4jUri = 'bolt://localhost:7687';
        this.neo4jDriver = null;
        
        // Ontology ì •ì˜
        this.ontology = {
            // ê°ì²´ íƒ€ì… ì •ì˜
            objectTypes: {
                'SourceFile': {
                    properties: {
                        fileName: 'string',
                        filePath: 'string',
                        extension: 'string',
                        size: 'number',
                        hash: 'string',
                        created: 'datetime',
                        modified: 'datetime',
                        language: 'string',
                        purpose: 'string',
                        complexity: 'number',
                        dependencies: 'array'
                    }
                },
                'Documentation': {
                    properties: {
                        title: 'string',
                        type: 'string', // API, Guide, Reference, etc.
                        format: 'string', // MD, TXT, PDF
                        topics: 'array',
                        references: 'array',
                        lastUpdated: 'datetime',
                        autoGenerated: 'boolean'
                    }
                },
                'Function': {
                    properties: {
                        name: 'string',
                        parameters: 'array',
                        returnType: 'string',
                        description: 'string',
                        category: 'string',
                        isExported: 'boolean',
                        isAsync: 'boolean',
                        complexity: 'number'
                    }
                },
                'AIAgent': {
                    properties: {
                        agentId: 'string',
                        name: 'string',
                        category: 'string',
                        capabilities: 'array',
                        complexity: 'string',
                        model: 'string'
                    }
                },
                'APIEndpoint': {
                    properties: {
                        path: 'string',
                        method: 'string',
                        parameters: 'array',
                        responseType: 'string',
                        authentication: 'boolean',
                        rateLimit: 'number'
                    }
                },
                'TestCase': {
                    properties: {
                        name: 'string',
                        targetFile: 'string',
                        type: 'string', // unit, integration, e2e
                        status: 'string',
                        coverage: 'number'
                    }
                },
                'Configuration': {
                    properties: {
                        name: 'string',
                        environment: 'string',
                        values: 'object',
                        sensitive: 'boolean'
                    }
                }
            },
            
            // ì—°ê²° íƒ€ì… ì •ì˜ (ê´€ê³„)
            linkTypes: {
                'IMPORTS': {
                    from: 'SourceFile',
                    to: 'SourceFile',
                    properties: {
                        importType: 'string', // default, named, namespace
                        alias: 'string'
                    }
                },
                'DOCUMENTS': {
                    from: 'Documentation',
                    to: ['SourceFile', 'Function', 'AIAgent'],
                    properties: {
                        section: 'string',
                        autoUpdated: 'boolean'
                    }
                },
                'CALLS': {
                    from: ['Function', 'AIAgent'],
                    to: ['Function', 'APIEndpoint'],
                    properties: {
                        frequency: 'number',
                        isAsync: 'boolean'
                    }
                },
                'TESTS': {
                    from: 'TestCase',
                    to: ['SourceFile', 'Function'],
                    properties: {
                        coverage: 'number',
                        lastRun: 'datetime'
                    }
                },
                'CONFIGURES': {
                    from: 'Configuration',
                    to: ['SourceFile', 'AIAgent'],
                    properties: {
                        required: 'boolean'
                    }
                },
                'REFERENCES': {
                    from: 'Documentation',
                    to: 'Documentation',
                    properties: {
                        referenceType: 'string' // see-also, extends, replaces
                    }
                },
                'COLLABORATES_WITH': {
                    from: 'AIAgent',
                    to: 'AIAgent',
                    properties: {
                        collaborationType: 'string', // sequential, parallel, hybrid
                        frequency: 'number'
                    }
                }
            },
            
            // ì•¡ì…˜ ì •ì˜
            actions: {
                'classify': 'Classify file into ontology',
                'analyze': 'Deep analysis of file content',
                'link': 'Create relationships between objects',
                'update': 'Update object properties',
                'query': 'Query objects and relationships'
            }
        };
        
        // ë¶„ì„ ê²°ê³¼ ìºì‹œ
        this.analysisCache = new Map();
        
        // íŒŒì¼ íŒŒì„œ ë§¤í•‘
        this.parsers = {
            '.js': this.parseJavaScript.bind(this),
            '.ts': this.parseTypeScript.bind(this),
            '.jsx': this.parseJSX.bind(this),
            '.tsx': this.parseTSX.bind(this),
            '.md': this.parseMarkdown.bind(this),
            '.json': this.parseJSON.bind(this),
            '.yml': this.parseYAML.bind(this),
            '.yaml': this.parseYAML.bind(this)
        };
    }
    
    // ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    async initialize() {
        console.log(chalk.cyan('ğŸš€ Initializing Palantir Ontology Classifier...'));
        
        // MongoDB ì—°ê²°
        try {
            this.mongoClient = new MongoClient(this.mongoUri);
            await this.mongoClient.connect();
            this.db = this.mongoClient.db('mathDB');
            this.objectsCollection = this.db.collection('ontology_objects');
            this.linksCollection = this.db.collection('ontology_links');
            console.log(chalk.green('  âœ“ MongoDB connected'));
        } catch (error) {
            console.log(chalk.yellow('  âš  MongoDB not available, using in-memory storage'));
            this.useInMemoryStorage();
        }
        
        // Neo4j ì—°ê²°
        try {
            this.neo4jDriver = neo4j.driver(
                this.neo4jUri,
                neo4j.auth.basic('neo4j', 'password')
            );
            await this.neo4jDriver.verifyConnectivity();
            console.log(chalk.green('  âœ“ Neo4j connected'));
        } catch (error) {
            console.log(chalk.yellow('  âš  Neo4j not available, using simplified graph'));
            this.useSimplifiedGraph();
        }
        
        // ì¸ë±ìŠ¤ ìƒì„±
        await this.createIndexes();
        
        console.log(chalk.green('âœ… Ontology system initialized'));
    }
    
    // In-memory ìŠ¤í† ë¦¬ì§€ ëŒ€ì²´
    useInMemoryStorage() {
        this.inMemoryObjects = new Map();
        this.inMemoryLinks = [];
        this.objectsCollection = {
            insertOne: async (doc) => {
                this.inMemoryObjects.set(doc._id, doc);
                return { insertedId: doc._id };
            },
            findOne: async (query) => {
                for (const [id, obj] of this.inMemoryObjects) {
                    if (this.matchQuery(obj, query)) return obj;
                }
                return null;
            },
            find: (query) => ({
                toArray: async () => {
                    const results = [];
                    for (const [id, obj] of this.inMemoryObjects) {
                        if (this.matchQuery(obj, query)) results.push(obj);
                    }
                    return results;
                }
            }),
            updateOne: async (filter, update) => {
                for (const [id, obj] of this.inMemoryObjects) {
                    if (this.matchQuery(obj, filter)) {
                        Object.assign(obj, update.$set || {});
                        return { modifiedCount: 1 };
                    }
                }
                return { modifiedCount: 0 };
            }
        };
        
        this.linksCollection = {
            insertOne: async (doc) => {
                this.inMemoryLinks.push(doc);
                return { insertedId: doc._id };
            },
            find: (query) => ({
                toArray: async () => {
                    return this.inMemoryLinks.filter(link => this.matchQuery(link, query));
                }
            })
        };
    }
    
    // ê°„ë‹¨í•œ ì¿¼ë¦¬ ë§¤ì¹­
    matchQuery(obj, query) {
        for (const [key, value] of Object.entries(query)) {
            if (obj[key] !== value) return false;
        }
        return true;
    }
    
    // ë‹¨ìˆœí™”ëœ ê·¸ë˜í”„ ì‚¬ìš©
    useSimplifiedGraph() {
        this.simpleGraph = {
            nodes: new Map(),
            edges: []
        };
    }
    
    // ì¸ë±ìŠ¤ ìƒì„±
    async createIndexes() {
        if (this.objectsCollection.createIndex) {
            await this.objectsCollection.createIndex({ type: 1 });
            await this.objectsCollection.createIndex({ 'properties.fileName': 1 });
            await this.objectsCollection.createIndex({ 'properties.hash': 1 });
        }
    }
    
    // íŒŒì¼ ë¶„ë¥˜ ë° ë¶„ì„
    async classifyFile(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        const stat = fs.statSync(filePath);
        const content = fs.readFileSync(filePath, 'utf-8');
        const hash = crypto.createHash('md5').update(content).digest('hex');
        
        // ìºì‹œ í™•ì¸
        if (this.analysisCache.has(hash)) {
            return this.analysisCache.get(hash);
        }
        
        // ê¸°ë³¸ ê°ì²´ ìƒì„±
        const baseObject = {
            _id: hash,
            type: this.determineObjectType(filePath, content),
            properties: {
                fileName: path.basename(filePath),
                filePath: filePath,
                extension: ext,
                size: stat.size,
                hash: hash,
                created: stat.birthtime,
                modified: stat.mtime
            }
        };
        
        // íŒŒì¼ íƒ€ì…ë³„ ìƒì„¸ ë¶„ì„
        if (this.parsers[ext]) {
            const analysis = await this.parsers[ext](content, filePath);
            Object.assign(baseObject.properties, analysis);
        }
        
        // ì˜ë¯¸ë¡ ì  ë¶„ì„
        const semanticAnalysis = await this.analyzeSemantics(content, baseObject.type);
        baseObject.semantics = semanticAnalysis;
        
        // ìºì‹œ ì €ì¥
        this.analysisCache.set(hash, baseObject);
        
        // DB ì €ì¥
        await this.saveObject(baseObject);
        
        return baseObject;
    }
    
    // ê°ì²´ íƒ€ì… ê²°ì •
    determineObjectType(filePath, content) {
        const fileName = path.basename(filePath);
        const ext = path.extname(filePath).toLowerCase();
        
        // í…ŒìŠ¤íŠ¸ íŒŒì¼
        if (fileName.includes('test') || fileName.includes('spec')) {
            return 'TestCase';
        }
        
        // ë¬¸ì„œ íŒŒì¼
        if (['.md', '.txt', '.pdf'].includes(ext)) {
            return 'Documentation';
        }
        
        // ì„¤ì • íŒŒì¼
        if (['.json', '.yml', '.yaml', '.env'].includes(ext) || fileName.includes('config')) {
            return 'Configuration';
        }
        
        // AI Agent íŒŒì¼
        if (content.includes('agent') || content.includes('Agent')) {
            return 'AIAgent';
        }
        
        // API ì—”ë“œí¬ì¸íŠ¸
        if (content.includes('app.get') || content.includes('app.post') || content.includes('router.')) {
            return 'APIEndpoint';
        }
        
        // ê¸°ë³¸: ì†ŒìŠ¤ íŒŒì¼
        return 'SourceFile';
    }
    
    // JavaScript íŒŒì¼ íŒŒì‹±
    async parseJavaScript(content, filePath) {
        const analysis = {
            language: 'JavaScript',
            functions: [],
            imports: [],
            exports: [],
            classes: [],
            dependencies: []
        };
        
        // Import ë¬¸ ì¶”ì¶œ
        const importRegex = /import\s+(?:{[^}]+}|\*\s+as\s+\w+|\w+)\s+from\s+['"]([^'"]+)['"]/g;
        let match;
        while ((match = importRegex.exec(content)) !== null) {
            analysis.imports.push({
                module: match[1],
                line: content.substring(0, match.index).split('\n').length
            });
            analysis.dependencies.push(match[1]);
        }
        
        // Require ë¬¸ ì¶”ì¶œ
        const requireRegex = /require\(['"]([^'"]+)['"]\)/g;
        while ((match = requireRegex.exec(content)) !== null) {
            analysis.imports.push({
                module: match[1],
                line: content.substring(0, match.index).split('\n').length
            });
            analysis.dependencies.push(match[1]);
        }
        
        // í•¨ìˆ˜ ì¶”ì¶œ
        const functionRegex = /(?:async\s+)?function\s+(\w+)\s*\([^)]*\)|(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s+)?\([^)]*\)\s*=>/g;
        while ((match = functionRegex.exec(content)) !== null) {
            const funcName = match[1] || match[2];
            analysis.functions.push({
                name: funcName,
                isAsync: match[0].includes('async'),
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // í´ë˜ìŠ¤ ì¶”ì¶œ
        const classRegex = /class\s+(\w+)(?:\s+extends\s+(\w+))?\s*{/g;
        while ((match = classRegex.exec(content)) !== null) {
            analysis.classes.push({
                name: match[1],
                extends: match[2] || null,
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // Export ë¬¸ ì¶”ì¶œ
        const exportRegex = /export\s+(?:default\s+)?(?:{[^}]+}|class\s+\w+|function\s+\w+|const\s+\w+|let\s+\w+|var\s+\w+)/g;
        while ((match = exportRegex.exec(content)) !== null) {
            analysis.exports.push({
                statement: match[0],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // ë³µì¡ë„ ê³„ì‚°
        analysis.complexity = this.calculateComplexity(content);
        
        // ëª©ì  ì¶”ë¡ 
        analysis.purpose = this.inferPurpose(filePath, content, analysis);
        
        return analysis;
    }
    
    // TypeScript íŒŒì¼ íŒŒì‹±
    async parseTypeScript(content, filePath) {
        // JavaScript íŒŒì‹± í™•ì¥
        const jsAnalysis = await this.parseJavaScript(content, filePath);
        
        // TypeScript íŠ¹ì • ìš”ì†Œ ì¶”ê°€
        const analysis = {
            ...jsAnalysis,
            language: 'TypeScript',
            interfaces: [],
            types: [],
            enums: []
        };
        
        // Interface ì¶”ì¶œ
        const interfaceRegex = /interface\s+(\w+)(?:\s+extends\s+([^{]+))?\s*{/g;
        let match;
        while ((match = interfaceRegex.exec(content)) !== null) {
            analysis.interfaces.push({
                name: match[1],
                extends: match[2] ? match[2].trim().split(',').map(s => s.trim()) : [],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // Type alias ì¶”ì¶œ
        const typeRegex = /type\s+(\w+)\s*=\s*([^;]+);/g;
        while ((match = typeRegex.exec(content)) !== null) {
            analysis.types.push({
                name: match[1],
                definition: match[2].trim(),
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // Enum ì¶”ì¶œ
        const enumRegex = /enum\s+(\w+)\s*{/g;
        while ((match = enumRegex.exec(content)) !== null) {
            analysis.enums.push({
                name: match[1],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        return analysis;
    }
    
    // JSX íŒŒì¼ íŒŒì‹±
    async parseJSX(content, filePath) {
        const jsAnalysis = await this.parseJavaScript(content, filePath);
        
        return {
            ...jsAnalysis,
            language: 'JSX',
            components: this.extractReactComponents(content)
        };
    }
    
    // TSX íŒŒì¼ íŒŒì‹±
    async parseTSX(content, filePath) {
        const tsAnalysis = await this.parseTypeScript(content, filePath);
        
        return {
            ...tsAnalysis,
            language: 'TSX',
            components: this.extractReactComponents(content)
        };
    }
    
    // React ì»´í¬ë„ŒíŠ¸ ì¶”ì¶œ
    extractReactComponents(content) {
        const components = [];
        
        // í•¨ìˆ˜í˜• ì»´í¬ë„ŒíŠ¸
        const funcCompRegex = /(?:export\s+)?(?:const|function)\s+([A-Z]\w+)\s*[=:]/g;
        let match;
        while ((match = funcCompRegex.exec(content)) !== null) {
            components.push({
                name: match[1],
                type: 'functional',
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // í´ë˜ìŠ¤í˜• ì»´í¬ë„ŒíŠ¸
        const classCompRegex = /class\s+([A-Z]\w+)\s+extends\s+(?:React\.)?(?:Component|PureComponent)/g;
        while ((match = classCompRegex.exec(content)) !== null) {
            components.push({
                name: match[1],
                type: 'class',
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        return components;
    }
    
    // Markdown íŒŒì¼ íŒŒì‹±
    async parseMarkdown(content, filePath) {
        const analysis = {
            format: 'Markdown',
            headings: [],
            links: [],
            codeBlocks: [],
            images: []
        };
        
        // ì œëª© ì¶”ì¶œ
        const headingRegex = /^(#{1,6})\s+(.+)$/gm;
        let match;
        while ((match = headingRegex.exec(content)) !== null) {
            analysis.headings.push({
                level: match[1].length,
                text: match[2],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // ë§í¬ ì¶”ì¶œ
        const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
        while ((match = linkRegex.exec(content)) !== null) {
            analysis.links.push({
                text: match[1],
                url: match[2],
                isInternal: !match[2].startsWith('http')
            });
        }
        
        // ì½”ë“œ ë¸”ë¡ ì¶”ì¶œ
        const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
        while ((match = codeBlockRegex.exec(content)) !== null) {
            analysis.codeBlocks.push({
                language: match[1] || 'plain',
                content: match[2],
                line: content.substring(0, match.index).split('\n').length
            });
        }
        
        // ì´ë¯¸ì§€ ì¶”ì¶œ
        const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
        while ((match = imageRegex.exec(content)) !== null) {
            analysis.images.push({
                alt: match[1],
                src: match[2]
            });
        }
        
        // í† í”½ ì¶”ì¶œ (ì œëª© ê¸°ë°˜)
        analysis.topics = analysis.headings
            .filter(h => h.level <= 2)
            .map(h => h.text);
        
        return analysis;
    }
    
    // JSON íŒŒì¼ íŒŒì‹±
    async parseJSON(content, filePath) {
        try {
            const data = JSON.parse(content);
            
            return {
                format: 'JSON',
                isValid: true,
                keys: Object.keys(data),
                structure: this.analyzeJSONStructure(data),
                isConfig: path.basename(filePath).includes('config') || 
                         path.basename(filePath) === 'package.json'
            };
        } catch (error) {
            return {
                format: 'JSON',
                isValid: false,
                error: error.message
            };
        }
    }
    
    // YAML íŒŒì¼ íŒŒì‹±
    async parseYAML(content, filePath) {
        // ê°„ë‹¨í•œ YAML ë¶„ì„ (ì‹¤ì œë¡œëŠ” yaml ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© ê¶Œì¥)
        return {
            format: 'YAML',
            lines: content.split('\n').length,
            isConfig: true
        };
    }
    
    // JSON êµ¬ì¡° ë¶„ì„
    analyzeJSONStructure(obj, depth = 0, maxDepth = 3) {
        if (depth > maxDepth) return '...';
        
        if (Array.isArray(obj)) {
            return obj.length > 0 ? 
                [`Array(${obj.length})`, this.analyzeJSONStructure(obj[0], depth + 1, maxDepth)] :
                'Array(0)';
        }
        
        if (obj && typeof obj === 'object') {
            const structure = {};
            for (const [key, value] of Object.entries(obj)) {
                structure[key] = typeof value === 'object' ? 
                    this.analyzeJSONStructure(value, depth + 1, maxDepth) :
                    typeof value;
            }
            return structure;
        }
        
        return typeof obj;
    }
    
    // ë³µì¡ë„ ê³„ì‚°
    calculateComplexity(content) {
        let complexity = 0;
        
        // ì¡°ê±´ë¬¸
        complexity += (content.match(/\bif\b/g) || []).length;
        complexity += (content.match(/\belse\b/g) || []).length;
        complexity += (content.match(/\bswitch\b/g) || []).length;
        complexity += (content.match(/\bcase\b/g) || []).length;
        
        // ë°˜ë³µë¬¸
        complexity += (content.match(/\bfor\b/g) || []).length;
        complexity += (content.match(/\bwhile\b/g) || []).length;
        complexity += (content.match(/\bdo\b/g) || []).length;
        
        // ì˜ˆì™¸ ì²˜ë¦¬
        complexity += (content.match(/\btry\b/g) || []).length;
        complexity += (content.match(/\bcatch\b/g) || []).length;
        
        // ë…¼ë¦¬ ì—°ì‚°ì
        complexity += (content.match(/&&/g) || []).length;
        complexity += (content.match(/\|\|/g) || []).length;
        
        return complexity;
    }
    
    // ëª©ì  ì¶”ë¡ 
    inferPurpose(filePath, content, analysis) {
        const fileName = path.basename(filePath).toLowerCase();
        
        // íŒŒì¼ëª… ê¸°ë°˜ ì¶”ë¡ 
        if (fileName.includes('test')) return 'Testing';
        if (fileName.includes('config')) return 'Configuration';
        if (fileName.includes('util') || fileName.includes('helper')) return 'Utility';
        if (fileName.includes('component')) return 'UI Component';
        if (fileName.includes('service')) return 'Service Layer';
        if (fileName.includes('model')) return 'Data Model';
        if (fileName.includes('controller')) return 'Controller';
        if (fileName.includes('route')) return 'Routing';
        if (fileName.includes('middleware')) return 'Middleware';
        
        // ë‚´ìš© ê¸°ë°˜ ì¶”ë¡ 
        if (analysis.classes && analysis.classes.length > 0) {
            if (analysis.classes.some(c => c.extends && c.extends.includes('Component'))) {
                return 'React Component';
            }
        }
        
        if (content.includes('app.get') || content.includes('app.post')) {
            return 'API Server';
        }
        
        if (content.includes('mongoose') || content.includes('sequelize')) {
            return 'Database Model';
        }
        
        return 'General Purpose';
    }
    
    // ì˜ë¯¸ë¡ ì  ë¶„ì„
    async analyzeSemantics(content, objectType) {
        const semantics = {
            keywords: [],
            entities: [],
            intents: [],
            domain: null
        };
        
        // í‚¤ì›Œë“œ ì¶”ì¶œ (ê°„ë‹¨í•œ ë²„ì „)
        const keywords = new Set();
        
        // í”„ë¡œê·¸ë˜ë° ê´€ë ¨ í‚¤ì›Œë“œ
        const progKeywords = ['async', 'await', 'promise', 'callback', 'stream', 'buffer', 
                              'api', 'rest', 'graphql', 'websocket', 'database', 'cache'];
        progKeywords.forEach(kw => {
            if (content.toLowerCase().includes(kw)) {
                keywords.add(kw);
            }
        });
        
        // AI/ML ê´€ë ¨ í‚¤ì›Œë“œ
        const aiKeywords = ['agent', 'model', 'training', 'inference', 'neural', 'embedding',
                           'claude', 'qwen', 'gpt', 'llm', 'prompt', 'completion'];
        aiKeywords.forEach(kw => {
            if (content.toLowerCase().includes(kw)) {
                keywords.add(kw);
            }
        });
        
        semantics.keywords = Array.from(keywords);
        
        // ë„ë©”ì¸ ì¶”ë¡ 
        if (semantics.keywords.some(k => aiKeywords.includes(k))) {
            semantics.domain = 'AI/ML';
        } else if (semantics.keywords.includes('api') || semantics.keywords.includes('rest')) {
            semantics.domain = 'Backend';
        } else if (content.includes('React') || content.includes('Component')) {
            semantics.domain = 'Frontend';
        } else if (objectType === 'TestCase') {
            semantics.domain = 'Testing';
        } else if (objectType === 'Documentation') {
            semantics.domain = 'Documentation';
        }
        
        return semantics;
    }
    
    // ê°ì²´ ì €ì¥
    async saveObject(object) {
        try {
            const existing = await this.objectsCollection.findOne({ _id: object._id });
            if (existing) {
                await this.objectsCollection.updateOne(
                    { _id: object._id },
                    { $set: object }
                );
            } else {
                await this.objectsCollection.insertOne(object);
            }
        } catch (error) {
            console.error('Error saving object:', error);
        }
    }
    
    // ê´€ê³„ ìƒì„±
    async createLink(fromId, toId, linkType, properties = {}) {
        const link = {
            _id: `${fromId}-${linkType}-${toId}`,
            from: fromId,
            to: toId,
            type: linkType,
            properties: properties,
            created: new Date()
        };
        
        try {
            await this.linksCollection.insertOne(link);
            
            // Neo4jì—ë„ ì €ì¥ (ê°€ëŠ¥í•œ ê²½ìš°)
            if (this.neo4jDriver) {
                const session = this.neo4jDriver.session();
                await session.run(
                    `MATCH (a {id: $fromId}), (b {id: $toId})
                     MERGE (a)-[r:${linkType}]->(b)
                     SET r = $properties`,
                    { fromId, toId, properties }
                );
                await session.close();
            }
        } catch (error) {
            console.error('Error creating link:', error);
        }
    }
    
    // ì „ì²´ í”„ë¡œì íŠ¸ ìŠ¤ìº” ë° ë¶„ë¥˜
    async scanProject() {
        console.log(chalk.cyan('ğŸ” Scanning entire project...'));
        
        const startTime = Date.now();
        const results = {
            processed: 0,
            objects: {},
            links: [],
            errors: []
        };
        
        // ì¬ê·€ì  íŒŒì¼ ìŠ¤ìº”
        const scanDir = async (dir) => {
            const files = fs.readdirSync(dir);
            
            for (const file of files) {
                const fullPath = path.join(dir, file);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory()) {
                    // ì œì™¸í•  ë””ë ‰í† ë¦¬
                    if (!['node_modules', '.git', '.venv', 'venv', '__pycache__'].includes(file)) {
                        await scanDir(fullPath);
                    }
                } else {
                    try {
                        const object = await this.classifyFile(fullPath);
                        results.processed++;
                        
                        if (!results.objects[object.type]) {
                            results.objects[object.type] = [];
                        }
                        results.objects[object.type].push(object);
                        
                        // ì§„í–‰ ìƒí™© ì¶œë ¥
                        if (results.processed % 100 === 0) {
                            console.log(chalk.gray(`  Processed ${results.processed} files...`));
                        }
                    } catch (error) {
                        results.errors.push({
                            file: fullPath,
                            error: error.message
                        });
                    }
                }
            }
        };
        
        await scanDir(this.projectPath);
        
        // ê´€ê³„ ë¶„ì„
        console.log(chalk.cyan('ğŸ”— Analyzing relationships...'));
        await this.analyzeRelationships(results.objects);
        
        const endTime = Date.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);
        
        console.log(chalk.green(`\nâœ… Scan complete!`));
        console.log(chalk.white(`  Processed: ${results.processed} files`));
        console.log(chalk.white(`  Duration: ${duration}s`));
        console.log(chalk.white(`  Errors: ${results.errors.length}`));
        
        // í†µê³„ ì¶œë ¥
        console.log(chalk.cyan('\nğŸ“Š Object Type Distribution:'));
        for (const [type, objects] of Object.entries(results.objects)) {
            console.log(chalk.white(`  ${type}: ${objects.length}`));
        }
        
        return results;
    }
    
    // ê´€ê³„ ë¶„ì„
    async analyzeRelationships(objects) {
        // Import ê´€ê³„ ë¶„ì„
        for (const sourceFiles of Object.values(objects)) {
            for (const file of sourceFiles) {
                if (file.properties.dependencies) {
                    for (const dep of file.properties.dependencies) {
                        // ë‚´ë¶€ ì˜ì¡´ì„± ì°¾ê¸°
                        const targetFile = await this.findFileByImport(dep, objects);
                        if (targetFile) {
                            await this.createLink(
                                file._id,
                                targetFile._id,
                                'IMPORTS',
                                { module: dep }
                            );
                        }
                    }
                }
            }
        }
        
        // ë¬¸ì„œ ê´€ê³„ ë¶„ì„
        if (objects.Documentation) {
            for (const doc of objects.Documentation) {
                if (doc.properties.references) {
                    for (const ref of doc.properties.references) {
                        const targetDoc = await this.findDocByReference(ref, objects);
                        if (targetDoc) {
                            await this.createLink(
                                doc._id,
                                targetDoc._id,
                                'REFERENCES',
                                { referenceType: 'see-also' }
                            );
                        }
                    }
                }
            }
        }
        
        // í…ŒìŠ¤íŠ¸ ê´€ê³„ ë¶„ì„
        if (objects.TestCase) {
            for (const test of objects.TestCase) {
                const targetFile = await this.findTestTarget(test, objects);
                if (targetFile) {
                    await this.createLink(
                        test._id,
                        targetFile._id,
                        'TESTS',
                        { coverage: test.properties.coverage || 0 }
                    );
                }
            }
        }
    }
    
    // Importë¡œ íŒŒì¼ ì°¾ê¸°
    async findFileByImport(importPath, objects) {
        // ìƒëŒ€ ê²½ë¡œ ì²˜ë¦¬
        if (importPath.startsWith('./') || importPath.startsWith('../')) {
            // ì‹¤ì œ ê²½ë¡œ ê³„ì‚° ë¡œì§ í•„ìš”
            return null;
        }
        
        // ì ˆëŒ€ ê²½ë¡œ ë˜ëŠ” ëª¨ë“ˆëª…
        for (const files of Object.values(objects)) {
            for (const file of files) {
                if (file.properties.fileName.includes(importPath)) {
                    return file;
                }
            }
        }
        
        return null;
    }
    
    // ì°¸ì¡°ë¡œ ë¬¸ì„œ ì°¾ê¸°
    async findDocByReference(reference, objects) {
        if (!objects.Documentation) return null;
        
        for (const doc of objects.Documentation) {
            if (doc.properties.fileName === reference || 
                doc.properties.title === reference) {
                return doc;
            }
        }
        
        return null;
    }
    
    // í…ŒìŠ¤íŠ¸ ëŒ€ìƒ ì°¾ê¸°
    async findTestTarget(test, objects) {
        const testFileName = test.properties.fileName;
        const targetName = testFileName
            .replace('.test.', '.')
            .replace('-test.', '.')
            .replace('test-', '');
        
        for (const files of Object.values(objects)) {
            for (const file of files) {
                if (file.properties.fileName === targetName) {
                    return file;
                }
            }
        }
        
        return null;
    }
    
    // ì¿¼ë¦¬ ì‹¤í–‰
    async query(queryObj) {
        const results = await this.objectsCollection.find(queryObj).toArray();
        return results;
    }
    
    // Claude-Qwen í˜‘ì—…ì„ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
    async generateCollaborationContext(taskType) {
        const context = {
            timestamp: new Date().toISOString(),
            taskType: taskType,
            relevantObjects: [],
            relationships: [],
            recommendations: []
        };
        
        // ì‘ì—… íƒ€ì…ì— ë”°ë¥¸ ê´€ë ¨ ê°ì²´ ìˆ˜ì§‘
        switch (taskType) {
            case 'code-review':
                context.relevantObjects = await this.query({
                    type: 'SourceFile',
                    'properties.modified': { $gte: new Date(Date.now() - 24*60*60*1000) }
                });
                break;
                
            case 'documentation':
                context.relevantObjects = await this.query({
                    type: { $in: ['Documentation', 'APIEndpoint'] }
                });
                break;
                
            case 'testing':
                context.relevantObjects = await this.query({
                    type: 'TestCase'
                });
                break;
                
            case 'architecture':
                context.relevantObjects = await this.query({
                    type: { $in: ['SourceFile', 'AIAgent', 'APIEndpoint'] }
                });
                break;
        }
        
        // ê´€ê³„ ìˆ˜ì§‘
        for (const obj of context.relevantObjects) {
            const links = await this.linksCollection.find({
                $or: [{ from: obj._id }, { to: obj._id }]
            }).toArray();
            context.relationships.push(...links);
        }
        
        // ì¶”ì²œ ìƒì„±
        context.recommendations = this.generateRecommendations(context);
        
        return context;
    }
    
    // ì¶”ì²œ ìƒì„±
    generateRecommendations(context) {
        const recommendations = [];
        
        // ì¤‘ë³µ íŒŒì¼ ì œê±° ì¶”ì²œ
        const duplicates = new Map();
        context.relevantObjects.forEach(obj => {
            const key = obj.properties.hash;
            if (duplicates.has(key)) {
                recommendations.push({
                    type: 'remove-duplicate',
                    priority: 'high',
                    files: [duplicates.get(key), obj._id]
                });
            } else {
                duplicates.set(key, obj._id);
            }
        });
        
        // ë¬¸ì„œí™” í•„ìš” ì¶”ì²œ
        const undocumented = context.relevantObjects.filter(obj => 
            obj.type === 'SourceFile' && 
            !context.relationships.some(link => 
                link.type === 'DOCUMENTS' && link.to === obj._id
            )
        );
        
        if (undocumented.length > 0) {
            recommendations.push({
                type: 'add-documentation',
                priority: 'medium',
                files: undocumented.map(o => o._id)
            });
        }
        
        // í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ì¶”ì²œ
        const untested = context.relevantObjects.filter(obj =>
            obj.type === 'SourceFile' &&
            !context.relationships.some(link =>
                link.type === 'TESTS' && link.to === obj._id
            )
        );
        
        if (untested.length > 0) {
            recommendations.push({
                type: 'add-tests',
                priority: 'medium',
                files: untested.map(o => o._id)
            });
        }
        
        return recommendations;
    }
    
    // ì‹œìŠ¤í…œ ì¢…ë£Œ
    async shutdown() {
        console.log(chalk.yellow('\nğŸ›‘ Shutting down Ontology Classifier...'));
        
        if (this.mongoClient) {
            await this.mongoClient.close();
        }
        
        if (this.neo4jDriver) {
            await this.neo4jDriver.close();
        }
        
        console.log(chalk.green('âœ… Shutdown complete'));
    }
}

// ë©”ì¸ ì‹¤í–‰
async function main() {
    const projectPath = 'C:\\palantir\\math';
    const classifier = new PalantirOntologyClassifier(projectPath);
    
    console.log(chalk.cyan.bold('ğŸš€ Palantir Ontology-Based File Classification System'));
    console.log(chalk.gray('=====================================================\n'));
    
    try {
        // ì´ˆê¸°í™”
        await classifier.initialize();
        
        // í”„ë¡œì íŠ¸ ìŠ¤ìº”
        const results = await classifier.scanProject();
        
        // ê²°ê³¼ ì €ì¥
        const reportPath = path.join(projectPath, 'ontology-classification-report.json');
        fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
        console.log(chalk.green(`\nğŸ“„ Report saved to: ${reportPath}`));
        
        // Claude-Qwen í˜‘ì—… ì»¨í…ìŠ¤íŠ¸ ìƒì„±
        console.log(chalk.cyan('\nğŸ¤ Generating Claude-Qwen collaboration contexts...'));
        
        const contexts = {};
        for (const taskType of ['code-review', 'documentation', 'testing', 'architecture']) {
            contexts[taskType] = await classifier.generateCollaborationContext(taskType);
            console.log(chalk.white(`  âœ“ ${taskType}: ${contexts[taskType].relevantObjects.length} objects`));
        }
        
        // í˜‘ì—… ì»¨í…ìŠ¤íŠ¸ ì €ì¥
        const contextPath = path.join(projectPath, 'claude-qwen-context.json');
        fs.writeFileSync(contextPath, JSON.stringify(contexts, null, 2));
        console.log(chalk.green(`\nğŸ“„ Collaboration context saved to: ${contextPath}`));
        
        // ì¢…ë£Œ
        await classifier.shutdown();
        
    } catch (error) {
        console.error(chalk.red('âŒ Error:'), error);
        await classifier.shutdown();
        process.exit(1);
    }
}

// ì‹¤í–‰
if (require.main === module) {
    main().catch(console.error);
}

export default PalantirOntologyClassifier;